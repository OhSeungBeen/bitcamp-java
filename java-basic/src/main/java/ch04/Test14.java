// 비트 이동 연산자 : >>, >>>, <<
package ch04;

public class Test14 {

  public static void main(String[] args) {
    //>>> : 오른쪽으로 비트를 이동시킨다. 
    // => 경계를 넘어 가는 값은 버린다.
    // => 왼쪽 빈자리는 0비트로 채운다.
    int a = 0xca; // 66
    System.out.println(Integer.toHexString(a >> 4));
    System.out.println(a >> 4);
    //00000000_00000000_00000000_11001010
    //    0000_00000000_00000000_00001100|1010
    //00000000_00000000_00000000_00001100
    
    System.out.println(Integer.toHexString(a >> 3));
    System.out.println(a >> 3);
    //00000000_00000000_00000000_11001010
    //   00000_00000000_00000000_00011001|010
    //00000000_00000000_00000000_00011001
    
    System.out.println(Integer.toHexString(a >> 2));
    System.out.println(a >> 2);
    //00000000_00000000_00000000_11001010
    //  000000_00000000_00000000_00110010|10
    //00000000_00000000_00000000_00011010
    
    System.out.println(Integer.toHexString(a >> 1));
    System.out.println(a >> 1);
    //00000000_00000000_00000000_11001010
    // 0000000_00000000_00000000_01100101|0
    //00000000_00000000_00000000_00110101
    
    // 오른쪽 비트 이동의 효과
    // => 1비트 이동할 때 마다 2로 나누는 효과가 있다.
    // => 예) n에 대해 x비트를 오른쪽으로 이동 = n /2**x
    // => 나누기 연산을 수행하는 것 보다 계산 속도가 빠르다.
    
    // 음수 값에 대해 오른쪽으로 비트 이동할 때 왼쪽 빈자리가 0으로 채워지므로 거대한 큰 양수 값으로 바뀐다.
   // => 2**n으로 나눈 것과 같다.
    // 소수점 이하를 반올림 한 결과가 나온다.
    // 왼쪽 빈자리가 부호비트로 채워진다
    a = -202; // 11111111_11111111_11111111_00110110 = 0xff_ff_ff_36
    System.out.println(a >>> 1); // -201 / 2**1 = -101
              //  1111111_11111111_11111111_0011011|0   <== 넘어 가는 값은 버린다. 
              //  0111111_11111111_11111111_0011011     <== 빈자리는 0비트로 채운다.
           //  0x7f_ff_ff_9b = -101
    System.out.println(a >>> 2); 
    System.out.println(a >>> 3); 
    System.out.println(a >>> 4);
    System.out.println(Integer.MAX_VALUE);
    
  }
}
